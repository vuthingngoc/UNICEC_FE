{"ast":null,"code":"var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',\n    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',\n    prefix = bind !== 'addEventListener' ? 'on' : '',\n    toArray = require('./to-array');\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el, NodeList, HTMLCollection or Array\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\n\n\nexports.bind = function (el, type, fn, capture) {\n  el = toArray(el);\n\n  for (var i = 0, il = el.length; i < il; i++) {\n    el[i][bind](prefix + type, fn, capture || false);\n  }\n};\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el, NodeList, HTMLCollection or Array\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\n\n\nexports.unbind = function (el, type, fn, capture) {\n  el = toArray(el);\n\n  for (var i = 0, il = el.length; i < il; i++) {\n    el[i][unbind](prefix + type, fn, capture || false);\n  }\n};\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * `wait` milliseconds. If `immediate` is true, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @param {Function} fn\n * @param {Integer} wait\n * @param {Boolean} immediate\n * @api public\n */\n\n\nexports.debounce = function (fn, wait, immediate) {\n  var timeout;\n  return wait ? function () {\n    var context = this,\n        args = arguments;\n\n    var later = function later() {\n      timeout = null;\n      if (!immediate) fn.apply(context, args);\n    };\n\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) fn.apply(context, args);\n  } : fn;\n};","map":{"version":3,"sources":["C:/Users/PC/Desktop/UNICS_FE/node_modules/list.js/src/utils/events.js"],"names":["bind","window","addEventListener","unbind","removeEventListener","prefix","toArray","require","exports","el","type","fn","capture","i","il","length","debounce","wait","immediate","timeout","context","args","arguments","later","apply","callNow","clearTimeout","setTimeout"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,MAAM,CAACC,gBAAP,GAA0B,kBAA1B,GAA+C,aAA1D;AAAA,IACEC,MAAM,GAAGF,MAAM,CAACG,mBAAP,GAA6B,qBAA7B,GAAqD,aADhE;AAAA,IAEEC,MAAM,GAAGL,IAAI,KAAK,kBAAT,GAA8B,IAA9B,GAAqC,EAFhD;AAAA,IAGEM,OAAO,GAAGC,OAAO,CAAC,YAAD,CAHnB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAC,OAAO,CAACR,IAAR,GAAe,UAAUS,EAAV,EAAcC,IAAd,EAAoBC,EAApB,EAAwBC,OAAxB,EAAiC;AAC9CH,EAAAA,EAAE,GAAGH,OAAO,CAACG,EAAD,CAAZ;;AACA,OAAK,IAAII,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGL,EAAE,CAACM,MAAxB,EAAgCF,CAAC,GAAGC,EAApC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3CJ,IAAAA,EAAE,CAACI,CAAD,CAAF,CAAMb,IAAN,EAAYK,MAAM,GAAGK,IAArB,EAA2BC,EAA3B,EAA+BC,OAAO,IAAI,KAA1C;AACD;AACF,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAJ,OAAO,CAACL,MAAR,GAAiB,UAAUM,EAAV,EAAcC,IAAd,EAAoBC,EAApB,EAAwBC,OAAxB,EAAiC;AAChDH,EAAAA,EAAE,GAAGH,OAAO,CAACG,EAAD,CAAZ;;AACA,OAAK,IAAII,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGL,EAAE,CAACM,MAAxB,EAAgCF,CAAC,GAAGC,EAApC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3CJ,IAAAA,EAAE,CAACI,CAAD,CAAF,CAAMV,MAAN,EAAcE,MAAM,GAAGK,IAAvB,EAA6BC,EAA7B,EAAiCC,OAAO,IAAI,KAA5C;AACD;AACF,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAJ,OAAO,CAACQ,QAAR,GAAmB,UAAUL,EAAV,EAAcM,IAAd,EAAoBC,SAApB,EAA+B;AAChD,MAAIC,OAAJ;AACA,SAAOF,IAAI,GACP,YAAY;AACV,QAAIG,OAAO,GAAG,IAAd;AAAA,QACEC,IAAI,GAAGC,SADT;;AAEA,QAAIC,KAAK,GAAG,SAARA,KAAQ,GAAY;AACtBJ,MAAAA,OAAO,GAAG,IAAV;AACA,UAAI,CAACD,SAAL,EAAgBP,EAAE,CAACa,KAAH,CAASJ,OAAT,EAAkBC,IAAlB;AACjB,KAHD;;AAIA,QAAII,OAAO,GAAGP,SAAS,IAAI,CAACC,OAA5B;AACAO,IAAAA,YAAY,CAACP,OAAD,CAAZ;AACAA,IAAAA,OAAO,GAAGQ,UAAU,CAACJ,KAAD,EAAQN,IAAR,CAApB;AACA,QAAIQ,OAAJ,EAAad,EAAE,CAACa,KAAH,CAASJ,OAAT,EAAkBC,IAAlB;AACd,GAZM,GAaPV,EAbJ;AAcD,CAhBD","sourcesContent":["var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',\n  unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',\n  prefix = bind !== 'addEventListener' ? 'on' : '',\n  toArray = require('./to-array')\n\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el, NodeList, HTMLCollection or Array\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\n\nexports.bind = function (el, type, fn, capture) {\n  el = toArray(el)\n  for (var i = 0, il = el.length; i < il; i++) {\n    el[i][bind](prefix + type, fn, capture || false)\n  }\n}\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el, NodeList, HTMLCollection or Array\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\n\nexports.unbind = function (el, type, fn, capture) {\n  el = toArray(el)\n  for (var i = 0, il = el.length; i < il; i++) {\n    el[i][unbind](prefix + type, fn, capture || false)\n  }\n}\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * `wait` milliseconds. If `immediate` is true, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @param {Function} fn\n * @param {Integer} wait\n * @param {Boolean} immediate\n * @api public\n */\n\nexports.debounce = function (fn, wait, immediate) {\n  var timeout\n  return wait\n    ? function () {\n        var context = this,\n          args = arguments\n        var later = function () {\n          timeout = null\n          if (!immediate) fn.apply(context, args)\n        }\n        var callNow = immediate && !timeout\n        clearTimeout(timeout)\n        timeout = setTimeout(later, wait)\n        if (callNow) fn.apply(context, args)\n      }\n    : fn\n}\n"]},"metadata":{},"sourceType":"script"}