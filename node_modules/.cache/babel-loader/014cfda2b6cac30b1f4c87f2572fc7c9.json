{"ast":null,"code":"module.exports = function (text, pattern, options) {\n  // Aproximately where in the text is the pattern expected to be found?\n  var Match_Location = options.location || 0; //Determines how close the match must be to the fuzzy location (specified above). An exact letter match which is 'distance' characters away from the fuzzy location would score as a complete mismatch. A distance of '0' requires the match be at the exact location specified, a threshold of '1000' would require a perfect match to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n\n  var Match_Distance = options.distance || 100; // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match (of both letters and location), a threshold of '1.0' would match anything.\n\n  var Match_Threshold = options.threshold || 0.4;\n  if (pattern === text) return true; // Exact match\n\n  if (pattern.length > 32) return false; // This algorithm cannot be used\n  // Set starting location at beginning text and initialise the alphabet.\n\n  var loc = Match_Location,\n      s = function () {\n    var q = {},\n        i;\n\n    for (i = 0; i < pattern.length; i++) {\n      q[pattern.charAt(i)] = 0;\n    }\n\n    for (i = 0; i < pattern.length; i++) {\n      q[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n    }\n\n    return q;\n  }(); // Compute and return the score for a match with e errors and x location.\n  // Accesses loc and pattern through being a closure.\n\n\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length,\n        proximity = Math.abs(loc - x);\n\n    if (!Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n\n    return accuracy + proximity / Match_Distance;\n  }\n\n  var score_threshold = Match_Threshold,\n      // Highest score beyond which we give up.\n  best_loc = text.indexOf(pattern, loc); // Is there a nearby exact match? (speedup)\n\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold); // What about in the other direction? (speedup)\n\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n\n    if (best_loc != -1) {\n      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  } // Initialise the bit arrays.\n\n\n  var matchmask = 1 << pattern.length - 1;\n  best_loc = -1;\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    } // Use the result from this iteration as the maximum for the next.\n\n\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n\n      if (d === 0) {\n        // First pass: exact match.\n        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;\n      } else {\n        // Subsequent passes: fuzzy match.\n        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];\n      }\n\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1); // This match will almost certainly be better than any existing match.\n        // But check anyway.\n\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    } // No hope for a (better) match at greater error levels.\n\n\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n\n    last_rd = rd;\n  }\n\n  return best_loc < 0 ? false : true;\n};","map":{"version":3,"sources":["C:/Users/PC/Desktop/UNICS_FE/node_modules/list.js/src/utils/fuzzy.js"],"names":["module","exports","text","pattern","options","Match_Location","location","Match_Distance","distance","Match_Threshold","threshold","length","loc","s","q","i","charAt","match_bitapScore_","e","x","accuracy","proximity","Math","abs","score_threshold","best_loc","indexOf","min","lastIndexOf","matchmask","bin_min","bin_mid","bin_max","last_rd","d","floor","start","max","finish","rd","Array","j","charMatch","score"],"mappings":"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","sourcesContent":["module.exports = function (text, pattern, options) {\n  // Aproximately where in the text is the pattern expected to be found?\n  var Match_Location = options.location || 0\n\n  //Determines how close the match must be to the fuzzy location (specified above). An exact letter match which is 'distance' characters away from the fuzzy location would score as a complete mismatch. A distance of '0' requires the match be at the exact location specified, a threshold of '1000' would require a perfect match to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  var Match_Distance = options.distance || 100\n\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match (of both letters and location), a threshold of '1.0' would match anything.\n  var Match_Threshold = options.threshold || 0.4\n\n  if (pattern === text) return true // Exact match\n  if (pattern.length > 32) return false // This algorithm cannot be used\n\n  // Set starting location at beginning text and initialise the alphabet.\n  var loc = Match_Location,\n    s = (function () {\n      var q = {},\n        i\n\n      for (i = 0; i < pattern.length; i++) {\n        q[pattern.charAt(i)] = 0\n      }\n\n      for (i = 0; i < pattern.length; i++) {\n        q[pattern.charAt(i)] |= 1 << (pattern.length - i - 1)\n      }\n\n      return q\n    })()\n\n  // Compute and return the score for a match with e errors and x location.\n  // Accesses loc and pattern through being a closure.\n\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length,\n      proximity = Math.abs(loc - x)\n\n    if (!Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy\n    }\n    return accuracy + proximity / Match_Distance\n  }\n\n  var score_threshold = Match_Threshold, // Highest score beyond which we give up.\n    best_loc = text.indexOf(pattern, loc) // Is there a nearby exact match? (speedup)\n\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold)\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length)\n\n    if (best_loc != -1) {\n      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold)\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1)\n  best_loc = -1\n\n  var bin_min, bin_mid\n  var bin_max = pattern.length + text.length\n  var last_rd\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0\n    bin_mid = bin_max\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid\n      } else {\n        bin_max = bin_mid\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min)\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid\n    var start = Math.max(1, loc - bin_mid + 1)\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length\n\n    var rd = Array(finish + 2)\n    rd[finish + 1] = (1 << d) - 1\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)]\n      if (d === 0) {\n        // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch\n      } else {\n        // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1]\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1)\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score\n          best_loc = j - 1\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc)\n          } else {\n            // Already passed loc, downhill from here on in.\n            break\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break\n    }\n    last_rd = rd\n  }\n\n  return best_loc < 0 ? false : true\n}\n"]},"metadata":{},"sourceType":"script"}